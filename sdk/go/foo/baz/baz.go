// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package baz

import (
	"context"
	"reflect"

	"errors"
	"github.com/mmartyn/pulumi-foo/sdk/go/foo/internal"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/s3"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Baz struct {
	pulumi.ResourceState

	Bucket    s3.BucketOutput `pulumi:"bucket"`
	BucketTwo s3.BucketOutput `pulumi:"bucketTwo"`
}

// NewBaz registers a new resource with the given unique name, arguments, and options.
func NewBaz(ctx *pulumi.Context,
	name string, args *BazArgs, opts ...pulumi.ResourceOption) (*Baz, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Bucket == nil {
		return nil, errors.New("invalid value for required argument 'Bucket'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Baz
	err := ctx.RegisterRemoteComponentResource("foo:baz:Baz", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type bazArgs struct {
	Bucket *s3.Bucket `pulumi:"bucket"`
}

// The set of arguments for constructing a Baz resource.
type BazArgs struct {
	Bucket s3.BucketInput
}

func (BazArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*bazArgs)(nil)).Elem()
}

type BazInput interface {
	pulumi.Input

	ToBazOutput() BazOutput
	ToBazOutputWithContext(ctx context.Context) BazOutput
}

func (*Baz) ElementType() reflect.Type {
	return reflect.TypeOf((**Baz)(nil)).Elem()
}

func (i *Baz) ToBazOutput() BazOutput {
	return i.ToBazOutputWithContext(context.Background())
}

func (i *Baz) ToBazOutputWithContext(ctx context.Context) BazOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BazOutput)
}

// BazArrayInput is an input type that accepts BazArray and BazArrayOutput values.
// You can construct a concrete instance of `BazArrayInput` via:
//
//	BazArray{ BazArgs{...} }
type BazArrayInput interface {
	pulumi.Input

	ToBazArrayOutput() BazArrayOutput
	ToBazArrayOutputWithContext(context.Context) BazArrayOutput
}

type BazArray []BazInput

func (BazArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Baz)(nil)).Elem()
}

func (i BazArray) ToBazArrayOutput() BazArrayOutput {
	return i.ToBazArrayOutputWithContext(context.Background())
}

func (i BazArray) ToBazArrayOutputWithContext(ctx context.Context) BazArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BazArrayOutput)
}

// BazMapInput is an input type that accepts BazMap and BazMapOutput values.
// You can construct a concrete instance of `BazMapInput` via:
//
//	BazMap{ "key": BazArgs{...} }
type BazMapInput interface {
	pulumi.Input

	ToBazMapOutput() BazMapOutput
	ToBazMapOutputWithContext(context.Context) BazMapOutput
}

type BazMap map[string]BazInput

func (BazMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Baz)(nil)).Elem()
}

func (i BazMap) ToBazMapOutput() BazMapOutput {
	return i.ToBazMapOutputWithContext(context.Background())
}

func (i BazMap) ToBazMapOutputWithContext(ctx context.Context) BazMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BazMapOutput)
}

type BazOutput struct{ *pulumi.OutputState }

func (BazOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Baz)(nil)).Elem()
}

func (o BazOutput) ToBazOutput() BazOutput {
	return o
}

func (o BazOutput) ToBazOutputWithContext(ctx context.Context) BazOutput {
	return o
}

func (o BazOutput) Bucket() s3.BucketOutput {
	return o.ApplyT(func(v *Baz) s3.BucketOutput { return v.Bucket }).(s3.BucketOutput)
}

func (o BazOutput) BucketTwo() s3.BucketOutput {
	return o.ApplyT(func(v *Baz) s3.BucketOutput { return v.BucketTwo }).(s3.BucketOutput)
}

type BazArrayOutput struct{ *pulumi.OutputState }

func (BazArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Baz)(nil)).Elem()
}

func (o BazArrayOutput) ToBazArrayOutput() BazArrayOutput {
	return o
}

func (o BazArrayOutput) ToBazArrayOutputWithContext(ctx context.Context) BazArrayOutput {
	return o
}

func (o BazArrayOutput) Index(i pulumi.IntInput) BazOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Baz {
		return vs[0].([]*Baz)[vs[1].(int)]
	}).(BazOutput)
}

type BazMapOutput struct{ *pulumi.OutputState }

func (BazMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Baz)(nil)).Elem()
}

func (o BazMapOutput) ToBazMapOutput() BazMapOutput {
	return o
}

func (o BazMapOutput) ToBazMapOutputWithContext(ctx context.Context) BazMapOutput {
	return o
}

func (o BazMapOutput) MapIndex(k pulumi.StringInput) BazOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Baz {
		return vs[0].(map[string]*Baz)[vs[1].(string)]
	}).(BazOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BazInput)(nil)).Elem(), &Baz{})
	pulumi.RegisterInputType(reflect.TypeOf((*BazArrayInput)(nil)).Elem(), BazArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BazMapInput)(nil)).Elem(), BazMap{})
	pulumi.RegisterOutputType(BazOutput{})
	pulumi.RegisterOutputType(BazArrayOutput{})
	pulumi.RegisterOutputType(BazMapOutput{})
}
